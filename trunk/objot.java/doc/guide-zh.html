<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN">
<!--
//
// Copyright 2007 Qianyan Cai
// Under the terms of The GNU General Public License version 2
//
-->
<html>
<head>
<meta name="Content-Type" content="text/html; charset=UTF-8" http-equiv="Content-Type">
<title>Objot 版本14 Java服务端指南</title>
<style>
	body	{ padding:0; margin:1em; background:white; line-height:1.4; font-family:sans-serif; }
	h2		{ margin:3em 0 1em; padding:0.2ex 0; border-bottom:0.3ex solid #cdf; color:#730; }
	h3		{ margin:2em 0 1em 1em; padding:0; color:#015; }
	h4		{ margin:2em 0 1em 2em; padding:0; color:#015; }
	a:link		{ color: #04e; text-decoration:none; }
	a:visited	{ color: #60c; text-decoration:none; }
	a:hover		{ background:#ddf; }
	table	{ margin:0 3ex 1em; background:#f6f6f6; }
	td		{ padding:0 1ex 0.3ex; border-bottom:1px solid #ee9; }
	pre		{ margin:1ex 2ex; padding:0.6ex; border:1px solid #cc6; background:#f2f2f2; line-height:1; }
</style>
</head>
<body>


<!--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-->


<h1	align=center><a href=http://objot.info>Objot</a> 版本14 Java服务端指南</h1>
<hr>

<p>这是一个了解如何利用Objot开发Java服务端的指南。
关于Objot及浏览端开发请参考《Objot 版本14 指南》。

<p>版权所有2007蔡倩彦，遵循GNU General Public License version 2。


<!--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-->


<h2>服务对象Service Object</h2>

<p>Java支持的SO类型包括：
<table>
	<tr><th>Javascript<th>Java</tr>
	<tr><td>null undefined<td>null</tr>
	<tr><td>boolean<td>boolean</tr>
	<tr><td>number<td>int long(部分) float double Integer Long(部分) Float Double</tr>
	<tr><td>string<td>String</tr>
	<tr><td>Date<td>Date</tr>
	<tr><td>Array<td>boolean[] int[] long[] &lt;T&gt;T[] List&lt;T&gt; Set&lt;T&gt;</tr>
	<tr><td>Object(非Function String Number Boolean)<td>Object Map&lt;String,Object&gt;</tr>
</table>
由于Javascript中超过32bit的补码整数用64bit浮点数表示，所以Java服务端默认限制long和Long的范围-562949953421312L到562949953421312L（+-49bit）。

<!--****************************************************************************************-->

<h3>服务端Service Object</h3>

<p>浏览端请参考《Objot 版本14 指南》。

<p>Java服务端也需要定义SO类，目前只支持field（以后版本将支持getter和setter）：
<pre>public class User {
	@GetSet // 被编解码，相当于@Get @Set
	public Integer id;

	@Get({DoUser.class, DoChat.class}) // 编码
	@Set({DoSign.class, DoUser.class}) // 解码
	public String name;

	public List<User> friends; // 不被编解码

	@GetSet(DoUser.class) // 相当于 @Get(DoUser.class) @Set(DoUser.class)
	@NameGet("friends") // 编码的名称
	public List&lt;User&gt; friends_;
}
</pre>
其中id、name、friends_被编码和解码，friends不被。
与任何类对应时，id均可编解码；与DoUser类对应时，friends_可编解码，并且编码名称为friends；与DoChat或者DoUser对应时，name可编码，与DoUser或DoSign对应时，name可解码。
@GetSet相当于@Get与@Set。

<p>在类上定义@Get、@Set、@GetSet，其设置的对应类将被插入到属性的@Get、@Set、@GetSet中：
<pre>@GetSet(DoChat.class)
public class Chat {
	@GetSet(Object.class) // 实际是@GetSet({DoChat.class, Object.class})
	public Integer id;

	@GetSet // 实际是@GetSet(DoChat.class)
	public User out;

	@GetSet 
	@Name("In") // 相当于@NameSet("In") @NameSet("In")
	public User in;

	public int internal; // 不被编解码
}
</pre>
如果属性上不定义@Get、@Set、@GetSet，则类的定义被忽略，仍然不被编解码。

<p>使用Hibernate等ORM时，可以将SO与对应的Persistent Object定义为同一个类：
<pre>public class User {
	@GetSet
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	public Integer id;

	@Get({DoUser.class, DoChat.class})
	@Set({DoSign.class, DoUser.class})
	public String name;

	@ManyToMany
	public List<User> friends;

	@GetSet(DoUser.class)
	@NameGet("friends")
	@Transient // 不在数据库里，只用在SO中
	public List&lt;User&gt; friends_;

	public int signedTimes; // 只用在PO和数据库中
}
</pre>

<!--****************************************************************************************-->

<h3>服务端编解码Service Object</h3>

<p>浏览端请参考《Objot 版本14 指南》。

<p>编解码前，先创建Objot对象：
<pre>Objot objot = new Objot();
</pre>
也可以创建Objot子类对象，并可定义如何作类名转换：
<pre>Objot objot = new Objot() {
	@Override
	protected Class&lt;?&gt; classByName(String name) throws Exception
	{
		return Class.forName("package.name.".concat(name));
	}
	@Override
	protected String className(Class&lt;?&gt; c) throws Exception
	{
		return c.getName().substring(c.getName().lastIndexOf('.') + 1);
	}
}
</pre>

<p>然后用这个objot对象来编解码SO：
<pre>User u1 = new User();
u1.id = 1;
u1.name = "user1";
u1.friends = new ArrayList&lt;User&gt;();
User u2 = new User();
u2.id = 2;
u2.name = "user2";
u2.friends = new ArrayList&lt;User&gt;();
...
u1.friends.add(u1);
u1.friends.add(u2);
u2.friends.add(...);
...
u1.friends_ = u1.friends;
CharSequence s = objot.get(Object.class, u1); // 对应Object，编码u1，结果为StringBuilder
u1.friends_ = null;
v1 = objot.set(
</pre>


<!--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-->


<h2>服务Service</h2>

<p>参考《Objot 版本14 指南》。
根据使用的Java框架和平台，可以用不同的方式来构建服务，Objot提供了Servlet的封装。

<!--****************************************************************************************-->

<h3>服务端Service</h3>


<!--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-->


<h2>视图View</h2>

<p>服务端不需要构建视图，浏览端请参考《Objot 版本14 指南》。
但是根据需要，可以通过不同的Servlet配置使面向服务的Objot和其他包含视图的框架共存。


<!--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-->


</body>
</html>

